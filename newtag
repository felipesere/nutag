#!/usr/bin/env bash
## Creates a new tag & validates with tag_police & pushes to origin
set -eu

if type update-juicy-scripts >/dev/null 2>&1; then
  # auto update if `update-juicy-scripts` is on path
  update-juicy-scripts --if-not-run-today || true
fi

version="0.5.4"

grey='\e[2m'
red='\e[91m'
yellow='\e[93m'
bold='\e[1m'
italic='\e[3m'
reset='\e[0m'

if [ -n "${1:-}" ]; then
  echo "newtag $version: Interactive release tagging & tag_police validation"
  echo
  echo "USAGE:"
  echo "    newtag"
  exit 1
fi

function increment_version() {
  [[ ${1} =~ ^(.*[^0-9])?([0-9]+)$ ]]  && \
    [[ ${#BASH_REMATCH[1]} -gt 0 ]] && \
      printf "%s%0${#BASH_REMATCH[2]}d" "${BASH_REMATCH[1]}" "$((10#${BASH_REMATCH[2]} + 1 ))" || \
      printf "%0${#BASH_REMATCH[2]}d" "$((10#${BASH_REMATCH[2]} + 1))" \
    printf "${1}"

}

# make sure tags are up-to-date
git fetch --tags

# show the current tag / distance from tag (error if not in git work tree)
if describe=$(git describe 2>&1); then
  # commit messages since last tag
  # try to remove `:` usage as this can screw up the yaml validation
  changes=$(git log --no-merges --format="%h %s" "$(git describe --abbrev=0)".. \
            | sed -r 's/^ */- /' | sed -r 's/(-.*):/\1 -/')

  describe_sans_obj="${describe%%-g*}"
  if [ "$describe_sans_obj" = "$describe" ]; then
    # We're on the latest tag
    printf "%b%s%b (no additional commits)%b\n" "$grey$bold" "$describe" "$reset$italic$grey" "$reset"
  else
    # Parse git describe: "v9.40.2-5-ga7d8c277" -> "v9.40.2 + 5 commits"
    printf "%b%s%b + %s commits%b\n" "$grey$bold" "${describe_sans_obj%%-[0-9]*}" "$reset$italic$grey" "${describe_sans_obj##*-}" "$reset"
    echo
    printf "%bChanges:\n" "$grey"
    echo "$changes"
    printf "%b" "$reset"
  fi
  echo
else # describe failed
  if [[ "$describe" == "fatal: No names found"* ]] || [[ "$describe" == "fatal: No tags"* ]]; then
    # A git repo but without any tags yet
    changes=$(git log --no-merges --format="%h %s" | sed -r 's/^ */- /' | sed -r 's/(-.*):/\1 -/')

    printf "%bNo previous tags%b\n" "$grey$bold" "$reset"
    echo
    printf "%bCommits:\n" "$grey"
    echo "$changes"
    printf "%b" "${reset}"
    describe=""
  else
    exit 128
  fi
fi

# try to propose the next version (or v0.1.0)
last_tag=${describe%%-[0-9]*}
proposed_tag=$(increment_version "$last_tag" 2> /dev/null)|| true
proposed_tag=${proposed_tag:-v0.1.0} # propose v0.1.0 as the first version of the repo
printf "Enter new tag name [%b%s%b]" "$italic" "$proposed_tag" "$reset"
read -p ": " -r tagname
echo

if [ -z "$tagname" ]; then
  tagname=$proposed_tag
fi

if [ -z "$tagname" ]; then
  printf "%bError: Empty tag%b\n" "$red" "$reset"
  exit 1
fi

current_branch=$(git branch --show-current)
on_main_branch=false
if [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
  on_main_branch=true
  else
  on_main_branch=false
fi

# reject pre tag on main/master branch
if [[ "$tagname" =~ "pre" ]] && [[ $on_main_branch == true ]]; then
  printf "%bError: Pre tag is not allowed on branch: %s%b\n" "$red" "$current_branch" "$reset"
  exit;
fi

# reject proper tag (eg. v1.0.0) on feature branches
if [[ ! "$tagname" =~ "pre" ]] && [[ $on_main_branch == false ]]; then
  printf "%bError: Only pre tags are allowed on branch: %s (eg. %s-pre0)%b\n" "$red" "$current_branch" "$tagname" "$reset"
  exit;
fi

# create the tag
git tag -am "release_notes:
$changes" "$tagname" --edit

# try to delete the tag if anything goes wrong
trap 'git tag -d "$tagname"' INT TERM ERR

# validate the tag if tag_police is available
if type tag_police >/dev/null 2>&1; then
  printf "%bRunning %btag_police%b\n" "$grey" "$italic" "$reset"
  tag_police "$tagname"
  echo
else
  printf "%bSkipping validation: %btag_police%b not found%b\n" "$yellow" "$italic" "$reset$yellow" "$reset"
  echo
fi

read -p "Push to origin? [Yn] " -n 1 -r
echo
echo
if [[ ! $REPLY =~ ^[Nn]$ ]]; then
  git push origin "$tagname"
fi

git show -q --oneline
